# Bash
Bash-комакды


Пройденные команды - ls, pwd, cd, touch, mkdir, cp, mv, rm, rmdir, su, man, info, whereis, whatis, apropos, which
Операции: 	; && $() | > >> < ||

----------------

	ls - выводит список файлов и каталогов
`ls /bin/ `- выведет список файлов и каталогов в папке bin

ls -R "путь" - показывает что находится в папке и в подпапках

ls -l "путь" - выводит список файлов и каталогов в подробной форме в столбец(- обычный файл или 
исполняемый, d каталог, l символьная ссылка, s сокет, b блочные устройства, c символьное устройство, p именнованный канал)

ls -m "путь" - выводит список файлов и каталогов через запятую как список

ls -a "путь" - выводит все Ф и К плюс скрытые

ls -F "путь" - выводит типы файлов и папок (/ - каталог, * - исполняемый файл и т.п)

ls -r 	- реверс, выводит в обратном порядке

ls -t - выводит с сортировкой по времени

ls -s - сортировка по размерам

ls>list - сохраняет список файлов в текущей директории в текстовый документ под именем list


--------------------

	pwd - показывает путь текущего положения(вывести текущий каталог)

cd /bin/ - переместимся в каталог bin

cd - 	- переместимся в предыдущий введенный каталог

cd ..  - переместимся вверх по каталогу(как бэкспэйс в проводнике)


touch - команда создает пустой файл, а также изменяет время доступа и время модификации файла

touch test - в текущем каталоге будет создан пустой файл с именем "test"

touch 1.txt 2.txt 3.txt - в текущем каталоге создаст три текстовых файла

touch -t 03022200 myscript	- данная команда изенит дату и время файла myscript (2 марта, 22.00)


mkdir - создает пустой каталог(папку)

mkdir newCatalog - создаст папку в текущей директории с названием newCatalog

mkdir -p k/k1/k2/k4/	- в текущем каталоге создает папку k,в которой хранится k1, в которой хранится k2, и т.д, другими словами команда созает вложенные папки

		
команда cp - копирует файлы

cp имя-источника целевой файл

cp test copytest - в текущей директории создаст копию файла test с именем copytest

cp test ./newCatalog/copytest - скопирует файл test из текущей директории и вставит его по указаному пути с именем copytest

touch 1.txt 2.txt 3.txt 4.txt
cp *.txt ./papka - скопируем все файлы с расширением txt из текущей директории в указанный путь(папку с именем papka) (по сути создаем шаблон)

cp 1[1-3].txt papka - создаем шаблон, который будет копировать файлы в папку papka с первой цифрой 1, а следующий символ диапозон от 1 до 3, с расширением txt. (а именно 11.txt, 12.txt, 13.txt) 

cp text1 text2 - если файл text2 уже существует , то он будет заменен на содержимое файла text1, без предупреждений, чтобы избежать этого следует сделать так:

cp -i text1 text2 - тогда если файл text2 уже существует, консоль спросит, вы уверенны что хотите заменить файл?(при вводе 'y' мы это потверждаем)

cp -R papka papka2 - копирует papka со всем ее содержимым в папку papka2

cp -v - отображает действия в консоли

		
команда mv - вырезает файл(перемещает а не копирует)

mv test papka/ - переместит файл тест в папку papka

Тоже самое можно делать и с папками

Также данную команду использую для переименовывания файлов :

mv test test2 - переименовали test в test2(на машинном уровне вырезали и вставили с новым именем)



команда rm - удаляет файлы

rm test - удалит файл test в текущей директории

при удалении можно использовать символ групповой операции *

	
команда rmdir - удаляет каталоги

rmdir papka - удалит папку в текущем каталоге (если папка пустая)

rm -Rf 2 - удаляет каталог , даже если он не пустой

Если название файла или каталога имеет пробел, тогда при вводе его в консоли , помещаем его в кавычки, например 'test'


команда su - позволяет выполнять действия от имени другого пользователя(переключение пользователя)

sudo passwd root - создание пароля для главного пользователя

adduser имя - создание нового пользователя

deluser имя -remove-home	- удаляет пользователя

su имя_пользователя - входим под другим пользователем (но каталог остается главного пользователя), чтобы перейти в каталог нового надо ввести su -

su - вход под root


команда man и info - команды получения информации

man ls - справочное руководство по команде ls(list)

man -k list - выдаст список всех команд в описании которых есть слово "list"

man -f ls 	- краткое описание команды ls

man -u - обновляет базу мануала

man ls > list - запишет информацию о команде ls в текстовый документ list

man man - описание самой команды man


команда whereis - информация где находится команда

whereis ls - выведет: ls: /bin/ls /usr/share/man/man1/ls.1.gz

whereis -b ls - информация о исполняемом файле ls

		

команда whatis - делает тоже самое что и man -f (краткое описание о команде)

whatis -w *ls  - выведет список команд с кратким описанием в которых есть символы ls


команда apropos - делает тоже самое что и man -k 

apropos list - выдаст список всех команд в описании которых есть слово "list"

команда which - делает тоже самое что и whereis -b



		
ОБЪЕДИНЕНИЕ КОМАНД

для объединения команд существуют определенные операции ; && | > >> <

; - позволяет выполнять последовательно команды, один за одним

apt-get install pidgin ; apt-get install pidgin-otr	- выполнится первая команда, затем вне зависимости от того, выполнилась ли успешно или нет первая, начнет выполняться вторая команда

ls -m ; pwd ; ls -F - последовательно выполнится три команды

&& - выполняет последовательно команды, но ПЛЮС проверяет каждую команду на успешность выполнения, если одна команда не выполнилась, то остальные тоже не выполняться

|| - если первая команда была закончена НЕУДАЧНО, то тогда  ВТОРАЯ ВЫПОЛНЯЕТСЯ. Если первая выполнена УСПЕШНО, то вторая НЕВЫПОЛНЯЕТСЯ

$() - копирует данные полученные из команды например:

date "+%Y-%m-%d" - команда выводит дату в формате 2017-08-09
mkdir $(date "+%Y-%m-%d") - создаст нам папку с именем 2017-08-09

поток ВВОДА: stdin
поток ВЫВОДА: stdout (дескриптор 1)
поток ОШИБОК: stderr (дескриптор 2)

| - обозначение канала

ls -l /bin/ | less - результат, который получился на выходе команды ls -l /bin/, мы передали команде less.


> - позволяет из потока stdout, записать информацию в файл

ls -l > test - сохранит вывод команды ls -l в файл test, но если использовать несколько раз и записывать в один и тот же файл, он будет какждый раз перезаписывать, ЧТОБЫ ЭТОГО ИЗБЕЖАТЬ воспользуемся следующей операцией:

>>  - дозаписывает данные (сохраняет все данные)

ls -l >> test
ls -m >> test

< - операция позволяет передавать информацию из файла определенной команде


команда cat - выводит содержимое каких либо файлов в поток stdout(с cat можно использовать различные операции объединения и т.п)

cat test - выведет содержимое файла test
cat test test2 - выведет содержимое двух файлов

cat test test2 > test3 - запишет содержимое двух файлов(test,test2) в третий файл test3

cat -n test2 - выведет в консоль содержимое файла test2 с пронумерованными строками


команда less - позволяет производить построчную и постраничную навигацию, похожа на cat

команда head - выводит первые 10 строк файла по умолчанию

head test - выведет первые 10 строк файла test

head test test2 - произойдет контатенация файлов, отобразит первые 10 строк каждого файла

head -n 5 test - выведет 5 первых строк файла test

head -c 100 test - выведет 100 байт файла
head -c 100k test - выведет 100кб файла


команда tail - выводит послдние 10 строк по умолчанию(всё тоже самое как и в head)



ПРАВА ДОСТУПА И ВЛАДЕНИЯ ФАЙЛАМИ


команда chgrp - позволяет изменять группу владельца

-rw-rw-r-- 1 valery xxx      330 Жнв  9 17:57 test - первое "-" тип файла, далее rw-(r - read, w - write) это права владельца, второй rw- это права группы владелец и r-- это права для всех остальных .

chgrp valery test - изменяет группу владельца файла test на valery.


команда chown - изменяет владельца файла

chown valery test - изменили владельца файла test на пользователя valery

Также мы можем СРАЗУ поменять и владельца и группу

chown xxx:xxx test - владелец и группа владельца файла test присвоено пользователю xxx
chown :xxx test - меняет только группу

При работе с каталогами используем РЕКУРСИЮ:

chown -R user papka


Существует три категории пользователей: u(владелец), g(группа), o(прочие пользователи).


Атрибуты которые ОПРЕДЕЛЯЮТ ДОСТУП К ФАЙЛУ:

r - атрибут чтения, разрешает читать файл.
w - атрибут записи, разрешает редактировать, удалять, переименовывать или добавлять файлы.
x - атрибут выполнения, позволяющий запускать на выполнение.
s - атрибут, позволяющий любому пользователю запустить файл на выполнение с правами его владельца.


команда chmod - управляет правами 

Пусть у нас есть файл с такими правами :
-rw-rw-r-- 1 valery xxx      330 Жнв  9 17:57 test

Мы хотим для прочих пользователей убрать право на чтение:

chmod o-r test - "о" обозначает что для прочих пользователей, "-" что мы убираем право, "r" указываем какое право хотим убрать в нашем случае право на чтение. Получаем : -rw-rw---- 1 valery xxx      330 Жнв  9 17:57 test

chmod o+r test - добавим для прочих пользователей право чтения файла test. Получаем:  -rw-rw-r-- 1 valery xxx      330 Жнв  9 17:57 test

chmod o+rwx test - добавили сразу несколько прав для прочих пользователей (чтение, запись и запуск)

chmod o= test - забрали все права для прочих пользователей.

chmod go=x test - для группы владельца и прочих пользователей оставляет только право X ( право запуска) ОСТАЛЬНЫЕ ПРАВА УБИРАЕТ.


Символьное представление r; w; x; 	Числовое представление данных атрибутов 4; 2; 1; идет по порядку  u g o

Числовое представлени:

0	---
1	--x
2	-w-
3	-wx
4	r--
5	r-x
6	rw-
7	rwx

chmod 660 test - получаем файл с такими правами доступа : rw-rw----, так как первая 6 относится к u, вторая 6 относится к g, и ноль относится к o




АРХИВАЦИЯ И СЖАТИЕ ФАЙЛОВ


du -h dir_1 - показывает размер каталога dir_1 в кБ

zip dir.zip dir_1 - архивируем каталог dir_1. А именно создаем архив dir.zip. (Целевой каталог dir_1 остается)

zip xxx.zip 1 2 3 4  - добавляем в архив 4 файла

unzip dir.zip - распаковать архив dir.zip в текущую директорию


Уровни сжатия бывают от 0 до 9 , по умолчанию ставится 6(шесть)

Ахивация под пароль происходит благодаря ключам -P (НЕБЕЗОПАСНЫЙ МЕТОД) и -e

zip -P asdf pass.zip 1 2 3 4 - создаем архив с паролем "asdf", который называется pass.zip и закидываем в него файлы 1 2 3 4 

zip -e pass.zip 1 2 3 - пароль вводится только после ввода этой команды

unzip -l xxx.zip - просмотр содержимого xxx.zip без распаковки

uncip -t xxx.zip - проверка целостности архива(проверка на ошибки)


команда gzip 

gzip 1.txt - создает архив, с именем 1.txt.gz, в который помещает файл 1.txt, и удаляет его из текущей директории.

gunzip 2.txt.gz - разарзивирует содержимое архива и удаляет сам архив.

команда bzip2

bzip2 1.txt - архивация
bunzip2 1.txt.bz2 - разархивация

команда  tar - Программа создает архивы, но не сжимает их.

tar -cf zipper.tar *.txt - закидываем в архив с именем zipper.tar все файлы с расширением .txt
tar -zcvf xxx.tar dir_1 - архивирует используя компресию (СЖИМАЕТ(использует зип для сжатия))
tar -zxvf xxx.tar - разархивируем
tar -zvtf xxx.tar - проверка целостности архива

ALIAS
Существует такое понятие как alias, это своеобразные настройки , которые мы хотим чтобы выполнялись при вводе какой-то команды.
Для того чтобы создать такой элиас нам надо открыть файл .bashrc. Например мы хотим чтобы при вводе ls, он всегда выводил нам ls -l, тогда в этом файле прописываем alias ls = 'ls -l' и сохраняем файл.



ПОИСК ДАННЫХ.

		
команда locate - поиск файлов ( по базе данных) . Чувствительна к регистру.

locate Пушкин - ищет все файлы с именем Пушкин (но только с большой буквы)

locate -i пушкин - теперь команда не чувствительна к регистру и найде все совпадения как и с большими буквами, так и с маленькими.\

locate -n 10 txt - выведет первые 10 строк из поиска

locate txt | tail -n 10 | less - выведет последние 10 строк поиска в виевре less.

updatedb - команда по обновлению базы


команда grep - ищет текст в файле

grep Пушкин doc.txt - будет искать слово Пушкин в файле doc.txt, и если найдет - выведет строку с этим словом

grep Пуш * - будет искать совпадения во всех файлах в текущей директории.

grep -R Пушкин * - будет искать не только в данной директории, но и ВО ВЛОЖЕННЫХ ПАПКАХ

grep -w мона * - ищет не просто вхождени "мона" а слово целиком, отдельное слово.



команда find - ищет файлы

find -name 'test' - ищет файлы с именем test
find -name '*test*' - ищет все файлы где есть слово test например : 8test, 45test5, test19.

find -user xxx - ищет файлы пользователя xxx

find -group xxx - ищет файлы группы xxx

find -type d - выводит список каталогов в текущей директории



УСТАНОВКА ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ


dpkg -i "путь скачанного файла" - устанавливает скачанные нами пакеты
dpkg -r "название программы" - удаляет указаную программу

apt-get install nmap - устанавливает программу nmap( можно указывать несколько программ через пробел)
apt-get remove nmap - удаляет программу nmap(могут оставаться конфигурационные файлы в директории
apt-get --purge remove nmap - удаляет все конфигурационные файлы , полностью стирает программу

apt-get update - загрузка списка обновлений
apt-get upgrade - обновляет все в системе.

apt-get update && apt-get upgrade

apt-get clean - чистит весь кэш закаченных инсталяционных пакетов

apt-get dist-upgrade - обновление версии дистрибутива



НАПИСАНИЕ СКРИПТОВ.
		
		
УТИЛИТА READ

echo "Please, enter your name!"
read var_name		- вводим значение в консоль, сохраняет его в переменную var_name
echo "Hello $var_name, nice to meet you!"  - выведет сообщение , вместо $var_name подставит значение переменной var_name
echo 'Hello $var_name, nice to meet you!' - в одинарных кавычках не воспримит $var_name как переменную и выведет текст Hello $var_name, nice to meet you!

-----------------------


read -p "Please, enter your name: " var_name - сразу выведет сообщение и после него поле для ввода переменной var_name
echo "Hello $var_name, nice to meet you!"



ПОЗОЦИОННЫЕ ПАРАМЕТРЫ

Запускаем скрипт в командной строке и передаем ему три параметра:
bash script04.sh 5 4 2

Скрипт имеет вид:

a=$1	- присваивает переменной первый введенный параметр (5)
b=$2	- присваивает переменной второй введенный параметр (4)
c=$3	- присваивает переменной третий введенный параметр (2)

clear
echo "First parametr is a=$a" - выведет 5
echo "Second parametr is b=$b" - 4
echo "Third parametr is c=$c"	-2
echo
echo '$0'"= $0"	- $0 выводит название скрипта
echo '$#'"= $#" - $# выводит количество переданных параметров (3)
echo '$*'"= $*"	- $* выводит все переданный параметры (5 4 2)

echo
e=$[$a+$b+$c] - присваиваем переменной сумма переменных a b c
echo "e = a+b+c = $e" - выведем в консоль переменную е
d="Good buy $USER" - присваиваем переменной строку "Good buy $USER" где $USER заменяется на имя текушего пользователя
echo "d = $d" - выведет переменную d

В результате выполнения скрипта получим такой вывод в консоли:

First parametr is a=5
Second parametr is b=4
Third parametr is c=2

$0= script04.sh
$#= 3
$*= 5 4 2

e = a+b+c = 11
d = Good buy valery

-------------------------------------------------

УТИЛИТА SET. ПЕРЕНАЗНАЧЕНИЕ ПОЗИЦИОННЫХ ПАРАМЕТРОВ

set 55 48 84 - задали три позиционных параметра 55 48 84
set `date` - задали позоционным параметром результат выполнения команды date

--------------------------------------------------

УТИЛИТА EXPR. МАТЕМАТИЧЕСКИЕ ОПЕРАЦИИ С ЦЕЛЫМИ ЧИСЛАМИ.

Запускаем скрипт в командной строке и передаем ему два параметра:
bash script05.sh 13 2

Код скрипта имеет вид:

a=10
b=5
c=$1 - присваиваем первый позиционный параметр
d=$2	- второй п.п
echo "a=$a"
echo "b=$b"
echo "c=$c"
echo "d=$d"
echo
echo 'a+b= '`expr $a + $b` - складываем a+b и выводим результат на экран, команду expr заключаем в обратную кавычку(находится где буква Ё), т.к по другому не будет воспринимать комнаду, также надо учитывать пробелы, при вызове команды expr и перечисление переменных и арифм.операций.
echo 'a-b= '`expr $a - $b` - вычитаем
echo 'a/b= '`expr $a / $b` - делим, при делении не вычисляет дробные числа, округляет до целых.
echo 'a*b= '`expr $a \* $b` - умножаем, причем при использовании команды expr, нам нужно звездочку экранировать обратным слешом \*,  при использовании в выражениях скобок ( или  ) тоже надо экранировать \( \)
echo
echo 'c+d= '`expr $c + $d`
echo 'c-d= '`expr $c - $d`
echo 'c/d= '`expr $c / $d`
echo 'c*d= '`expr $c \* $d`

В результате выполнения скрипта получим такой результат в консоли:

a=10
b=5
c=13
d=2

a+b= 15
a-b= 5
a/b= 2
a*b= 50

c+d= 15
c-d= 11
c/d= 6
c*d= 26

--------------------------------------------------------------
expr 5 "<" 10 - выведет 1 , так как это true
expr 5 ">"1= 10 - выведет 0, так как это false
expr 5 "!=" 10 - выведет 1, так как true
expr 5 "==" 5 - выведет 1, так как true

--------------------------------------------------------------
--------------------------------------------------------------


УТИЛИТА BC. МАТЕМАТИЧЕСКИЕ ОПЕРАЦИИ С ВЕЩЕСТВЕННЫМИ ЧИСЛАМИ.

Для демонстрации данной утилиты напишем скрипт, который выглядит вот так:

a=10.5
b=5.5
echo "a=$a"
echo "b=$b"
echo
c=`echo "scale = 2 ; $a + $b" | bc` - с помощью эхо выводим текст и передаем его команде bc, а затем результат выполнения присваиваем переменной с. scale = 2, обозначает сколько знаков будет после запятой при вычислении, затем ставим ; и пишем само математическое выражение.
d=`echo "scale = 2 ; $a - $b" | bc`
e=`echo "scale = 2 ; $a * $b" | bc`
f=`echo "scale = 2 ; $a / $b" | bc`
echo "c=a+b= $a + $b = $c"
echo "d=a-b= $a - $b = $d"
echo "e=a*b= $a * $b = $e"
echo "f=a/b= $a / $b = $f"

При выполнении даного скрипта получаем:

a=10.5
b=5.5

c=a+b= 10.5 + 5.5 = 16.0
d=a-b= 10.5 - 5.5 = 5.0
e=a*b= 10.5 * 5.5 = 57.75
f=a/b= 10.5 / 5.5 = 1.90

----------------------------------------------
----------------------------------------------


ДОПОЛНИТЕЛЬНЫЕ ВОЗМОЖНОСТИ УТИЛИТЫ ECHO.

echo -e "\033[37;1;41m Hello, my name Valery! \033[0m" - выведет тескт в консоли,цвет шрифта станет белым и сам текст станет выделеным красным маркером. Цифра 37 отвечает за цвет шрифта, изменяя её можно поменять цвет. 41 Отвечает за цвет фона. Цифра 1 отвечает за стиль текста(например 3 - курсив, 4 - подчеркнутый и т.д.]

-----------------------------------------------
-----------------------------------------------


ОПЕРАТОРЫ ВЕТВЛЕНИЯ IF-THEN.

При выполнении команд, они возвращают значения 0 или 1, если команда завершена успешно возвращает 0, если с ошибкой - возвращает 1.

Напишем скрипт, который при успешном выполнении команды переименовывает файл.
Код скрипта выглядит так:

echo "Здравствуйте, введите старое и новое  имя файла,через пробел, который вы хотите переименовать"
read oldname newname 	- считывает два слова через пробел и сохраняет их в переменные
echo "ls -m"
ls -m
if mv $oldname $newname 	- если команда mv выполнена успешно, переходим в блок then, иначе программа пропускает его
then		- тогда
echo "Переименовывание завершено успешно"
echo "ls -m"
ls -m
fi	-	обозначает конец блока


При запуске скрипта и вводе значений получаем:

Здравствуйте, введите старое и новое  имя файла,через пробел, который вы хотите переименовать: 
test newtest
ls -m
1.txt, 2.txt, 3.txt, bash_scripting, dir_1, doc, list, myscript, newCatalog,
test, test2, test3
Переименовывание завершено успешно
ls -m
1.txt, 2.txt, 3.txt, bash_scripting, dir_1, doc, list, myscript, newCatalog,
newtest, test2, test3


-------------------------------------------------
-------------------------------------------------

		ОПЕРАТОРЫ ВЕТВЛЕНИЯ IF-THEN-ELSE.

Доработаем предидущий скрипт и сделаем так, что если файла не существует(команда отработала с ошибкой), то мы выведем в консоль сообщение об ошибке.

echo "Здравствуйте, введите старое и новое  имя файла,через пробел, который вы $
read oldname newname
echo "ls -m"
ls -m
if mv $oldname $newname - если команда вернула 0(то есть выполнена успешно)
then	- тогда выполнить этот блок
echo "Переименовывание завершено успешно"
echo "ls -m"
ls -m
else	- иначе выполнить этот блок
echo " Ошибка! Файла не существует, либо другая ошибка."
fi

---------------------------------------------------
---------------------------------------------------

		КОНСТРУКЦИЯ ELIF.


Для наглядности напишем небольшой скрипт:

a=3
b=5
clear
echo -e "\nThis is the RiverFight: \n10-[ ]\n09-[ ]\n08-[ ]\n07-[ ]\n06-[ ]\n05-[ ]\n04-[ ]\n03-[ ]\n02-[ ]\n01-[ ]\n"
echo "Enter a number between 1 and 10:"
read num
if [ $num -lt $a ] -  если  num меньше a то выведем последующий блок
then
echo "It was too low! Try again!"
elif [ $num -gt $b ] - иначе если num больше a, то вывыдем последующий блок
then
echo "It was too high! Try again!"
else - иначе, если предидущие условия не выполнились, то выполеним последующий блок
echo -e "\nNice shot! You win!"
echo -e "\n10-[ ]\n09-[ ]\n08-[ ]\n07-[ ]\n06-[ ]\n05-[x]\n04-[x]\n03-[x]\n02-[ ]\n01-[ ]\n"
fi - завершаем нашу конструкцию

exit 0

---------------------------------------------------
---------------------------------------------------

		ФЛАГИ СРАВНЕНИЯ lt,gt,le,ge,eq

-lt	- меньше
-gt	- больше
-le	- меньше или равно
-ge	- больше или равно
-eq	- равно
-ne	- не равно

---------------------------------------------------
---------------------------------------------------


		СРАВНЕНИЕ СТРОКОВЫХ ПЕРЕМЕННЫХ

Для примера напишем скрипт, который будет сравнивать строки:

str1="Hello World"
str2="My name is Valera"
str3=""

clear
echo "str1=$str1"
echo "str2=$str2"
echo "str3=$str3"

echo -e "\nCheck if str1($str1)=str2($str2):" - "echo -e" не считывает бэкслэш как строку, а воспринимает \n как переход на новую строку
[ "$str1" = "$str2" ] - сравнивает две строки
echo $?	-	выведет 1, так как вышестоящее уравнение вернуло false(1)

echo -e "\nCheck if str1($str1) != str2($str2):"
[ "$str1" != "$str2" ]	-	строки не равны
echo $? 	- выведет 0, так как строки действительно не равны

echo -e "\nCheck if string str3($str3) _isn't_ empty:"
# -n string is not empty
[ -n "$str3" ] 	- проверяет, если строка не пустая - то true
echo $? 	- выведет 1, так как строка пустая

echo -e "\nCheck if string str3($str3) _is_ empty:"
# -z - empty line, length=0
[ -z "$str3" ] 	- проверяет, если строка пустая - то true
echo $?		- выведет 0, так как строка пустая

После выполнения скрипта, в консоли выведется:

str1=Hello World
str2=My name is Valera
str3=

Check if str1(Hello World)=str2(My name is Valera):
1

Check if str1(Hello World) != str2(My name is Valera):
0

Check if string str3() _isn't_ empty:
1

Check if string str3() _is_ empty:
0

-----------------------------------------------------
-----------------------------------------------------


		ЛОГИЧЕСКИЙ ОПЕРАТОР AND(-a)

Для примера напишем скрипт, который будет запрашивать пользователя, ввести число от 50 до 100, если пользователь вводит правильно, программа пищет что введено правильно, если нет, то соотвтетственно пишет обратное.

Код скрипта:


read -p "Введите значение от 50 до 100: " number 	- считали значение с клавиатуры и присвоили переменной number

if [ $number -ge 50 -a $number -le 100 ] 	- если number >= 50 и <=100, то выводим последующий блок
then
echo "Поздравляем, вы попали"
else 		- иначе выводим последующий блок.
echo "Увы, вы промазали"
fi

После выполнения скрипта, в консоли получим:

Введите значение от 50 до 100: 55
Поздравляем, вы попали


------------------------------------------------------
------------------------------------------------------


		ЛОГИЧЕСКИЙ ОПЕРАТОР ИЛИ(-o)


Для примера напишем скрипт, который просит пользователя ввести гласную букву, и проверяет гласная она или нет.

read -p "Введите гласную английскую букву: " var

if [ `echo "$var" | wc -c` -eq 2 ]	- проверяем чтобы количество введенных букв было равно 1, пишем равно 2 , так как enter тоже считается как символ
then
        if [ $var = a -o $var = i -o $var = u -o $var = e ]	- условия с оператором -o(или)
        then
                echo "Буква гласная!"
        else
                echo "Буква согласная!"
        fi
else
        echo "Вы ввели больше чем одну букву"
fi


В резульате выведет на консоль следующий результат:

Введите гласную английскую букву: d
Буква согласная!

------------------------------------------------------
------------------------------------------------------


		ОПЕРАТОР ВЕТВЛЕНИЯ CASE

Для примера напишем скрипт, который запрашивает пользователя ввсети символ, и напишет в консоль, чем является данный символ:

echo "Введите символ"
read var
case $var in	- открываем конструкцию case , пишем переменную которую хотим сравнить и с чем хотим сравнить
[a-z])		- если маленькие буквы английские, то выведет блок
        echo "Ввели букву в нижнем регистре";;
[A-Z])		- если большие английские буквы
        echo "Ввели букву в верхнем регистре";;
[0-9])		- если цифры
        echo "Ввели цифру";;
?)		- если остальные символы
        echo "Введен специальный символ";;
*)		- если больше одного символа
        echo "Вы ввели больше чем один символ";;
esac		- закрываем конструкию  case

exit 0

---------------------------------------------------------

Рассмотрим еще один, где вводим животное и программа выводит сколько лап оно имеет:

echo "Введите животное: "
read animal
echo -n "Животное $animal имеет "
case $animal in	
        horse | dog | cat) echo  "четыре лапы";;	- если animal равно horse или dog или cat то выполним последующий блок
        man | kangaroo) echo "две лапы";;		- если man или kangaroo то выполним последующтий блок
        *) echo  "Ошибка, неизвестное животное!";;	- если все остально то выполним последующий блок
esac

В результате выполнения программы получим вывод в консоль:

Введите животное: 
cat
Животное cat имеет четыре лапы


--------------------------------------------------------
--------------------------------------------------------

		ОПЕРАТОР ЦИКЛА WHILE

Для примера напишем скрипт который выводит числа от 1 до 10. 
Код скрипта выглядит следующим образом:

count=1
while [ $count -le 10 ]		- задаем условие, цикл будет работать пока count меньше или равно 10
do
        echo $count
        count=$(($count+1))	- присваиваем count +1
done

exit 0


------------------------------------------------------------
clear

packet_loss=0
tilltime=0
currenttime=0
i=0
temp_avarage_packetloss=0
avarage_packetloss=0

echo "Please, enter exact time, till which should ping test be made. Format HoursMinutes, like 1439."
read tilltime
currenttime=$(date +%H%M)
while [ $currenttime -lt $tilltime ]
do
currenttime=$(date +%H%M)
i=$(($i+1))
echo "ping test #$i"
echo "Current time is `date +%H:%M:%S`"
packet_loss=$(ping -c 5 -q ya.ru | grep -oP '\d+(?=% packet loss)')
echo "host= ya.ru"
echo "packet_loss= $packet_loss"
echo ""
temp_avarage_packetloss=$(($temp_avarage_packetloss+$packet_loss))
done

avarage_packetloss=$(($temp_avarage_packetloss/$i))
echo "Packet loss was $avarage_packetloss %"

exit 0

----------------------------------------------------------------

Вычисление среднего значения – Calculating an average:
~/tst-shell/v20.30$ cat v20.30-while-score.sh

#!/bin/bash

SCORE="0"
AVERAGE="0"
SUM="0"
NUM="0"

while true; do

echo -n "Enter your score [0-100%] ('q' for quit): "; read SCORE;

if (("$SCORE" < "0")) || (("$SCORE" > "100")); then
echo "Be serious. Common, try again: "
elif [ "$SCORE" == "q" ]; then
echo "Average rating: $AVERAGE%."
break
else
SUM=$[$SUM + $SCORE]
NUM=$[$NUM + 1]
AVERAGE=$[$SUM / $NUM]
fi

done

echo "Exiting."

-------------------------------------------------------------

Скрипт – бесконечный цикл:
:~/tst-shell/v20.30$ cat v20.30-while-infinite-loop.sh
#!/bin/bash
while :
do
echo "infinite loops [ hit CTRL+C to stop]"
sleep 0.5
done

-------------------------------------------------------------
------------------------------------------------------------




